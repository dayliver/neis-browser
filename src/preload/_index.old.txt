import { contextBridge, ipcRenderer, webFrame } from 'electron'

const api = {
  send: (channel, data) => ipcRenderer.send(channel, data),
  on: (channel, func) => {
    const subscription = (_event, ...args) => func(...args)
    ipcRenderer.on(channel, subscription)
    return () => ipcRenderer.removeListener(channel, subscription)
  },
  removeAllListeners: (channel) => ipcRenderer.removeAllListeners(channel),
  encryptPassword: (text) => ipcRenderer.invoke('encrypt-password', text),
  decryptPassword: (hex) => ipcRenderer.invoke('decrypt-password', hex),
  getPreloadPath: () => ipcRenderer.invoke('get-preload-path')
}

if (process.contextIsolated) {
  try { contextBridge.exposeInMainWorld('electron', { ipcRenderer: api }) } catch (e) {}
} else { window.electron = { ipcRenderer: api } }

if (!window.location.href.includes('localhost') && !window.location.href.includes('127.0.0.1')) {

  window.addEventListener('DOMContentLoaded', () => {
    console.log(`Preload: 로드 완료`);
    setupBasicFeatures();

    window.addEventListener('message', (event) => {
      if (event.data && event.data.type === 'NEIS_MENU_FOUND') {
        ipcRenderer.send('bridge-menu-data', event.data.payload);
      }
    });
  });

  ipcRenderer.on('req-extract-menu', () => {
    const script = document.createElement('script');
    script.textContent = `
      (function() {
        try {
          if (typeof cpr === 'undefined') return;
          var mainAppDef = cpr.core.Platform.INSTANCE.lookup("app/com/main/Index");
          if (!mainAppDef) return;
          var mainApp = mainAppDef.getInstances()[0];
          var ds = mainApp.lookup("dsAllMenu");
          var dataList = ds.getRowDataRanged();
          if (dataList && dataList.length > 0) {
             window.postMessage({ type: 'NEIS_MENU_FOUND', payload: dataList }, '*');
          }
        } catch (e) { console.error(e); }
      })();
    `;
    (document.head || document.documentElement).appendChild(script);
    script.remove();
  });

  ipcRenderer.on('req-execute-menu', (event, menuId, param) => {
    const paramStr = param ? JSON.stringify(param) : "null";
    const script = document.createElement('script');
    script.textContent = `
      (function() {
        try {
          var mainDef = cpr.core.Platform.INSTANCE.lookup("app/com/main/Index");
          var main = mainDef.getInstances()[0];
          if (main) {
             main.callAppMethod("doOpenMenuToMdi", "${menuId}", ${paramStr});
          }
        } catch (e) { console.error(e); }
      })();
    `;
    (document.head || document.documentElement).appendChild(script);
    script.remove();
  });


  // =========================================================
  // ★★★ [신규] 마우스 이벤트 시뮬레이션 함수 ★★★
  // =========================================================
  const simulateClick = (element, ms = 300) => new Promise(resolve => {
    const mouseOverEvent = new MouseEvent('mouseover', { bubbles: true, cancelable: true, view: window });
    const mouseDownEvent = new MouseEvent('mousedown', { bubbles: true, cancelable: true, view: window });
    const mouseUpEvent = new MouseEvent('mouseup', { bubbles: true, cancelable: true, view: window });
    const clickEvent = new MouseEvent('click', { bubbles: true, cancelable: true, view: window });

    element.dispatchEvent(mouseOverEvent);
    element.dispatchEvent(mouseDownEvent);
    element.dispatchEvent(mouseUpEvent);
    element.dispatchEvent(clickEvent);
    
    setTimeout(resolve, ms);
  });


  // =========================================================
  // 일괄 붙여넣기 실행 함수
  // =========================================================
  async function runBatchPaste(startRowIndex, startColIndex, dataList) {
    console.log(`[Batch] 시작: ${startRowIndex}행, ${startColIndex}열 / 데이터: ${dataList.length}건`);
    
    webFrame.setZoomFactor(0.3);
    await new Promise(r => setTimeout(r, 1000)); 

    let successCount = 0;

    for (let i = 0; i < dataList.length; i++) {
      const targetRowIdx = startRowIndex + i;
      const text = dataList[i];

      // 1. 행 찾기
      const rowEl = document.querySelector(`.cl-grid-row[aria-rowindex="${targetRowIdx}"]`);
      if (!rowEl) {
        console.warn(`행 미발견: ${targetRowIdx}`);
        break;
      }

      // 2. 열 찾기
      const cellEl = rowEl.querySelector(`.cl-grid-cell[data-cellindex="${startColIndex}"]`);
      if (!cellEl) {
        console.warn(`열 미발견: ${startColIndex}`);
        continue;
      }

      // 3. 시각적 표시
      cellEl.style.outline = "5px solid red"; 
      cellEl.scrollIntoView({block: "center", inline: "nearest"});

      // 4. ★★★ [수정] 정밀 타격 (simulateClick 사용) ★★★
      const clickTarget = cellEl.querySelector('.cl-text') || cellEl;
      
      console.log(`[${i}] 클릭 시뮬레이션 시도...`);
      await simulateClick(clickTarget, 300); // 300ms 대기

      // 5. 에디터(Textarea) 찾기
      // (전역 activeElement 확인)
      let activeInput = document.activeElement;
      while (activeInput && activeInput.shadowRoot && activeInput.shadowRoot.activeElement) {
        activeInput = activeInput.shadowRoot.activeElement;
      }

      // (혹시 activeElement가 안 잡히면 셀 내부 재검색)
      if (!activeInput || (activeInput.tagName !== 'TEXTAREA' && activeInput.tagName !== 'INPUT')) {
          activeInput = cellEl.querySelector('textarea');
      }

      if (activeInput && (activeInput.tagName === 'TEXTAREA' || activeInput.tagName === 'INPUT')) {
          console.log(`[성공] 에디터 활성화됨`);
          
          activeInput.focus();
          
          // 값 주입 (execCommand 우선 시도)
          const success = document.execCommand('insertText', false, text);
          if (!success) activeInput.value = text;

          activeInput.dispatchEvent(new Event('input', { bubbles: true }));
          activeInput.dispatchEvent(new Event('change', { bubbles: true }));
          
          // 엔터키 (저장 확정)
          activeInput.dispatchEvent(new KeyboardEvent('keydown', { bubbles: true, key: 'Enter', keyCode: 13 }));
          
          successCount++;
      } else {
          console.error(`[실패] ${targetRowIdx}행 - 에디터 활성화 실패`);
      }
      
      await new Promise(r => setTimeout(r, 100));
    }

    // 복구
    setTimeout(() => {
        webFrame.setZoomFactor(1.0);
        alert(`작업 완료!\n\n- 총 데이터: ${dataList.length}건\n- 성공(입력됨): ${successCount}건\n\n저장 버튼을 눌러 반영 여부를 꼭 확인하세요.`);
    }, 500);
  }


  function setupBasicFeatures() {
    // 1. 붙여넣기 감지
    window.addEventListener('keydown', async (e) => {
      if ((e.ctrlKey || e.metaKey) && (e.key === 'v' || e.key === 'V')) {
        
        // 1) 탭 이름 확인
        const activeTabEl = document.querySelector('.cl-tabfolder-item.cl-selected .cl-text');
        let isTargetTab = false;
        if (activeTabEl) {
          const currentTabName = activeTabEl.innerText.trim();
          const ALLOWED_TABS = ['과목별세부능력', '개인별세부능력', '동아리활동']; 
          isTargetTab = ALLOWED_TABS.some(tab => currentTabName.includes(tab));
        }
        if (!isTargetTab) return;

        // 2) 타겟 셀 확인
        const target = document.activeElement;
        const cell = target.closest('.cl-grid-cell');
        const row = target.closest('.cl-grid-row');

        if (cell && row) {
           e.preventDefault();
           e.stopImmediatePropagation();

           try {
             const clipboardItems = await navigator.clipboard.read();
             let isTable = false;
             let dataList = [];

             for (const item of clipboardItems) {
               if (item.types.includes('text/html')) {
                 const blob = await item.getType('text/html');
                 const html = await blob.text();
                 if (html.includes('<table') || html.includes('<tr')) {
                   isTable = true;
                   const parser = new DOMParser();
                   const doc = parser.parseFromString(html, 'text/html');
                   const rows = doc.querySelectorAll('tr');
                   rows.forEach(r => {
                      const col = r.querySelector('td'); 
                      if(col) dataList.push(col.innerText.trim()); 
                   });
                 }
               }
             }

             const colIdx = parseInt(cell.getAttribute('data-cellindex'), 10);
             const rowIdx = parseInt(row.getAttribute('aria-rowindex'), 10);

             if (isTable && dataList.length > 1) {
                if (confirm(`[일괄 붙여넣기]\n\n${rowIdx}행부터 ${dataList.length}건을 입력하시겠습니까?`)) {
                   runBatchPaste(rowIdx, colIdx, dataList);
                } else {
                   const text = await navigator.clipboard.readText();
                   document.execCommand('insertText', false, text);
                }
             } else {
                const text = await navigator.clipboard.readText();
                document.execCommand('insertText', false, text);
             }
           } catch (err) { console.error(err); }
        }
      }
    }, true);

    // 2. 단축키
    window.addEventListener('keydown', (e) => {
      if (e.key === 'F3' || (e.ctrlKey && (e.key === 'f' || e.key === 'F'))) {
        e.preventDefault(); e.stopPropagation();
        ipcRenderer.send('req-toggle-search');
      }
    }, true);

    // 3. 탭 열기
    document.addEventListener('click', (e) => {
      const menuBtn = e.target.closest('.menuBtn');
      if (menuBtn) {
        const url = menuBtn.getAttribute('id');
        if (url && url.startsWith('http')) {
          e.preventDefault(); e.stopImmediatePropagation();
          ipcRenderer.send('bridge-create-tab', url);
        }
      }
    }, true);

    // 4. 비밀번호
    setInterval(() => {
      const certInput = document.querySelector('input[name="certPassword"]');
      if (certInput && !certInput.dataset.listenerAttached) {
        certInput.addEventListener('click', () => {
          certInput.style.backgroundColor = 'cyan';
          ipcRenderer.send('req-type-password');
        });
        certInput.dataset.listenerAttached = 'true';
      }
    }, 500);
  }
}